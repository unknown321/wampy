// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: command.proto

#include "command.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Command {
PROTOBUF_CONSTEXPR Command::Command(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.Msg_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandDefaultTypeInternal() {}
  union {
    Command _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandDefaultTypeInternal _Command_default_instance_;
PROTOBUF_CONSTEXPR FeatureBigCover::FeatureBigCover(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct FeatureBigCoverDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeatureBigCoverDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeatureBigCoverDefaultTypeInternal() {}
  union {
    FeatureBigCover _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureBigCoverDefaultTypeInternal _FeatureBigCover_default_instance_;
PROTOBUF_CONSTEXPR FeatureShowClock::FeatureShowClock(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct FeatureShowClockDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeatureShowClockDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeatureShowClockDefaultTypeInternal() {}
  union {
    FeatureShowClock _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureShowClockDefaultTypeInternal _FeatureShowClock_default_instance_;
PROTOBUF_CONSTEXPR FeatureSetMaxVolume::FeatureSetMaxVolume(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.enabled_)*/false} {}
struct FeatureSetMaxVolumeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeatureSetMaxVolumeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeatureSetMaxVolumeDefaultTypeInternal() {}
  union {
    FeatureSetMaxVolume _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureSetMaxVolumeDefaultTypeInternal _FeatureSetMaxVolume_default_instance_;
PROTOBUF_CONSTEXPR WindowStatus::WindowStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.visible_)*/0} {}
struct WindowStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WindowStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WindowStatusDefaultTypeInternal() {}
  union {
    WindowStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WindowStatusDefaultTypeInternal _WindowStatus_default_instance_;
PROTOBUF_CONSTEXPR SetVolume::SetVolume(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.valuepercent_)*/0} {}
struct SetVolumeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetVolumeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetVolumeDefaultTypeInternal() {}
  union {
    SetVolume _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetVolumeDefaultTypeInternal _SetVolume_default_instance_;
PROTOBUF_CONSTEXPR Seek::Seek(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/0} {}
struct SeekDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SeekDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SeekDefaultTypeInternal() {}
  union {
    Seek _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SeekDefaultTypeInternal _Seek_default_instance_;
PROTOBUF_CONSTEXPR Track::Track(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.artist_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.track_)*/0
  , /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_.active_)*/false} {}
struct TrackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackDefaultTypeInternal() {}
  union {
    Track _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackDefaultTypeInternal _Track_default_instance_;
PROTOBUF_CONSTEXPR Playlist::Playlist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.track_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlaylistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlaylistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlaylistDefaultTypeInternal() {}
  union {
    Playlist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlaylistDefaultTypeInternal _Playlist_default_instance_;
PROTOBUF_CONSTEXPR Status::Status(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.codec_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.playlist_)*/nullptr
  , /*decltype(_impl_.elapsed_)*/0
  , /*decltype(_impl_.playstate_)*/0
  , /*decltype(_impl_.hires_)*/false
  , /*decltype(_impl_.shuffle_)*/false
  , /*decltype(_impl_.repeat_)*/0
  , /*decltype(_impl_.volume_)*/0
  , /*decltype(_impl_.bitrate_)*/0
  , /*decltype(_impl_.samplerate_)*/0
  , /*decltype(_impl_.bitdepth_)*/0
  , /*decltype(_impl_.volumeraw_)*/0} {}
struct StatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusDefaultTypeInternal() {}
  union {
    Status _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusDefaultTypeInternal _Status_default_instance_;
}  // namespace Command
static ::_pb::Metadata file_level_metadata_command_2eproto[10];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_command_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_command_2eproto = nullptr;

const uint32_t TableStruct_command_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::Command::Command, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command::Command, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::Command::Command, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::Command, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Command::Command, _impl_.code_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::Command::Command, _impl_.Msg_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Command::FeatureBigCover, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command::FeatureBigCover, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::FeatureBigCover, _impl_.enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::Command::FeatureShowClock, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command::FeatureShowClock, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::FeatureShowClock, _impl_.enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::Command::FeatureSetMaxVolume, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command::FeatureSetMaxVolume, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::FeatureSetMaxVolume, _impl_.enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::Command::WindowStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command::WindowStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::WindowStatus, _impl_.visible_),
  0,
  PROTOBUF_FIELD_OFFSET(::Command::SetVolume, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command::SetVolume, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::SetVolume, _impl_.valuepercent_),
  0,
  PROTOBUF_FIELD_OFFSET(::Command::Seek, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command::Seek, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::Seek, _impl_.value_),
  0,
  PROTOBUF_FIELD_OFFSET(::Command::Track, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command::Track, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::Track, _impl_.track_),
  PROTOBUF_FIELD_OFFSET(::Command::Track, _impl_.artist_),
  PROTOBUF_FIELD_OFFSET(::Command::Track, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::Command::Track, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::Command::Track, _impl_.active_),
  2,
  0,
  1,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Command::Playlist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::Playlist, _impl_.track_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.codec_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.elapsed_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.playstate_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.hires_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.shuffle_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.repeat_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.bitrate_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.samplerate_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.bitdepth_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.playlist_),
  PROTOBUF_FIELD_OFFSET(::Command::Status, _impl_.volumeraw_),
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  1,
  11,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 16, -1, sizeof(::Command::Command)},
  { 25, 32, -1, sizeof(::Command::FeatureBigCover)},
  { 33, 40, -1, sizeof(::Command::FeatureShowClock)},
  { 41, 48, -1, sizeof(::Command::FeatureSetMaxVolume)},
  { 49, 56, -1, sizeof(::Command::WindowStatus)},
  { 57, 64, -1, sizeof(::Command::SetVolume)},
  { 65, 72, -1, sizeof(::Command::Seek)},
  { 73, 84, -1, sizeof(::Command::Track)},
  { 89, -1, -1, sizeof(::Command::Playlist)},
  { 96, 114, -1, sizeof(::Command::Status)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Command::_Command_default_instance_._instance,
  &::Command::_FeatureBigCover_default_instance_._instance,
  &::Command::_FeatureShowClock_default_instance_._instance,
  &::Command::_FeatureSetMaxVolume_default_instance_._instance,
  &::Command::_WindowStatus_default_instance_._instance,
  &::Command::_SetVolume_default_instance_._instance,
  &::Command::_Seek_default_instance_._instance,
  &::Command::_Track_default_instance_._instance,
  &::Command::_Playlist_default_instance_._instance,
  &::Command::_Status_default_instance_._instance,
};

const char descriptor_table_protodef_command_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rcommand.proto\022\007Command\"\225\003\n\007Command\022\033\n\004"
  "Type\030\001 \002(\0162\r.Command.Type\022#\n\004Code\030\002 \002(\0162"
  "\025.Command.ResponseCode\022-\n\014WindowStatus\030\003"
  " \001(\0132\025.Command.WindowStatusH\000\022!\n\006Status\030"
  "\004 \001(\0132\017.Command.StatusH\000\022\'\n\tSetVolume\030\005 "
  "\001(\0132\022.Command.SetVolumeH\000\022\035\n\004Seek\030\006 \001(\0132"
  "\r.Command.SeekH\000\0223\n\017FeatureBigCover\030\007 \001("
  "\0132\030.Command.FeatureBigCoverH\000\0225\n\020Feature"
  "ShowClock\030\010 \001(\0132\031.Command.FeatureShowClo"
  "ckH\000\022;\n\023FeatureSetMaxVolume\030\t \001(\0132\034.Comm"
  "and.FeatureSetMaxVolumeH\000B\005\n\003Msg\"\"\n\017Feat"
  "ureBigCover\022\017\n\007enabled\030\001 \002(\010\"#\n\020FeatureS"
  "howClock\022\017\n\007enabled\030\001 \002(\010\"&\n\023FeatureSetM"
  "axVolume\022\017\n\007enabled\030\001 \002(\010\"7\n\014WindowStatu"
  "s\022\'\n\007Visible\030\001 \002(\0162\026.Command.WindowVisib"
  "le\"!\n\tSetVolume\022\024\n\014valuePercent\030\001 \002(\005\"\025\n"
  "\004Seek\022\r\n\005value\030\001 \002(\005\"W\n\005Track\022\r\n\005Track\030\001"
  " \002(\005\022\016\n\006Artist\030\002 \002(\t\022\r\n\005Title\030\003 \002(\t\022\020\n\010D"
  "uration\030\004 \002(\005\022\016\n\006Active\030\005 \002(\010\")\n\010Playlis"
  "t\022\035\n\005Track\030\001 \003(\0132\016.Command.Track\"\352\001\n\006Sta"
  "tus\022\r\n\005Codec\030\001 \002(\t\022\017\n\007Elapsed\030\002 \002(\005\022\021\n\tP"
  "layState\030\003 \002(\005\022\r\n\005HiRes\030\004 \002(\010\022\017\n\007Shuffle"
  "\030\005 \002(\010\022\016\n\006Repeat\030\006 \002(\005\022\016\n\006Volume\030\007 \002(\005\022\017"
  "\n\007BitRate\030\010 \001(\005\022\022\n\nSampleRate\030\t \001(\002\022\020\n\010B"
  "itDepth\030\n \001(\005\022#\n\010Playlist\030\013 \002(\0132\021.Comman"
  "d.Playlist\022\021\n\tVolumeRaw\030\014 \002(\005*\212\003\n\004Type\022\017"
  "\n\013CMD_UNKNOWN\020\000\022\031\n\025CMD_GET_WINDOW_STATUS"
  "\020\001\022\023\n\017CMD_HIDE_WINDOW\020\002\022\023\n\017CMD_SHOW_WIND"
  "OW\020\003\022\022\n\016CMD_GET_STATUS\020\004\022\014\n\010CMD_TEST\020\005\022\022"
  "\n\016CMD_SET_VOLUME\020\006\022\014\n\010CMD_SEEK\020\007\022\026\n\022CMD_"
  "TOGGLE_SHUFFLE\020\010\022\025\n\021CMD_TOGGLE_REPEAT\020\t\022"
  "\022\n\016CMD_NEXT_TRACK\020\n\022\022\n\016CMD_PREV_TRACK\020\013\022"
  "\014\n\010CMD_PLAY\020\014\022\r\n\tCMD_PAUSE\020\r\022\014\n\010CMD_STOP"
  "\020\016\022\031\n\025CMD_FEATURE_BIG_COVER\020\017\022\032\n\026CMD_FEA"
  "TURE_SHOW_CLOCK\020\020\022\017\n\013CMD_FAILURE\020\021\022\036\n\032CM"
  "D_FEATURE_SET_MAX_VOLUME\020\022*-\n\014ResponseCo"
  "de\022\013\n\007UNKNOWN\020\000\022\010\n\004FAIL\020\001\022\006\n\002OK\020\002*N\n\rWin"
  "dowVisible\022\026\n\022VISIBILITY_UNKNOWN\020\000\022\022\n\016VI"
  "SIBILITY_YES\020\001\022\021\n\rVISIBILITY_NO\020\002"
  ;
static ::_pbi::once_flag descriptor_table_command_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_command_2eproto = {
    false, false, 1553, descriptor_table_protodef_command_2eproto,
    "command.proto",
    &descriptor_table_command_2eproto_once, nullptr, 0, 10,
    schemas, file_default_instances, TableStruct_command_2eproto::offsets,
    file_level_metadata_command_2eproto, file_level_enum_descriptors_command_2eproto,
    file_level_service_descriptors_command_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_command_2eproto_getter() {
  return &descriptor_table_command_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_command_2eproto(&descriptor_table_command_2eproto);
namespace Command {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_command_2eproto);
  return file_level_enum_descriptors_command_2eproto[0];
}
bool Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_command_2eproto);
  return file_level_enum_descriptors_command_2eproto[1];
}
bool ResponseCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WindowVisible_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_command_2eproto);
  return file_level_enum_descriptors_command_2eproto[2];
}
bool WindowVisible_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Command::_Internal {
 public:
  using HasBits = decltype(std::declval<Command>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Command::WindowStatus& windowstatus(const Command* msg);
  static const ::Command::Status& status(const Command* msg);
  static const ::Command::SetVolume& setvolume(const Command* msg);
  static const ::Command::Seek& seek(const Command* msg);
  static const ::Command::FeatureBigCover& featurebigcover(const Command* msg);
  static const ::Command::FeatureShowClock& featureshowclock(const Command* msg);
  static const ::Command::FeatureSetMaxVolume& featuresetmaxvolume(const Command* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::Command::WindowStatus&
Command::_Internal::windowstatus(const Command* msg) {
  return *msg->_impl_.Msg_.windowstatus_;
}
const ::Command::Status&
Command::_Internal::status(const Command* msg) {
  return *msg->_impl_.Msg_.status_;
}
const ::Command::SetVolume&
Command::_Internal::setvolume(const Command* msg) {
  return *msg->_impl_.Msg_.setvolume_;
}
const ::Command::Seek&
Command::_Internal::seek(const Command* msg) {
  return *msg->_impl_.Msg_.seek_;
}
const ::Command::FeatureBigCover&
Command::_Internal::featurebigcover(const Command* msg) {
  return *msg->_impl_.Msg_.featurebigcover_;
}
const ::Command::FeatureShowClock&
Command::_Internal::featureshowclock(const Command* msg) {
  return *msg->_impl_.Msg_.featureshowclock_;
}
const ::Command::FeatureSetMaxVolume&
Command::_Internal::featuresetmaxvolume(const Command* msg) {
  return *msg->_impl_.Msg_.featuresetmaxvolume_;
}
void Command::set_allocated_windowstatus(::Command::WindowStatus* windowstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Msg();
  if (windowstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(windowstatus);
    if (message_arena != submessage_arena) {
      windowstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, windowstatus, submessage_arena);
    }
    set_has_windowstatus();
    _impl_.Msg_.windowstatus_ = windowstatus;
  }
  // @@protoc_insertion_point(field_set_allocated:Command.Command.WindowStatus)
}
void Command::set_allocated_status(::Command::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Msg();
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
    _impl_.Msg_.status_ = status;
  }
  // @@protoc_insertion_point(field_set_allocated:Command.Command.Status)
}
void Command::set_allocated_setvolume(::Command::SetVolume* setvolume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Msg();
  if (setvolume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(setvolume);
    if (message_arena != submessage_arena) {
      setvolume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setvolume, submessage_arena);
    }
    set_has_setvolume();
    _impl_.Msg_.setvolume_ = setvolume;
  }
  // @@protoc_insertion_point(field_set_allocated:Command.Command.SetVolume)
}
void Command::set_allocated_seek(::Command::Seek* seek) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Msg();
  if (seek) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seek);
    if (message_arena != submessage_arena) {
      seek = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seek, submessage_arena);
    }
    set_has_seek();
    _impl_.Msg_.seek_ = seek;
  }
  // @@protoc_insertion_point(field_set_allocated:Command.Command.Seek)
}
void Command::set_allocated_featurebigcover(::Command::FeatureBigCover* featurebigcover) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Msg();
  if (featurebigcover) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(featurebigcover);
    if (message_arena != submessage_arena) {
      featurebigcover = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, featurebigcover, submessage_arena);
    }
    set_has_featurebigcover();
    _impl_.Msg_.featurebigcover_ = featurebigcover;
  }
  // @@protoc_insertion_point(field_set_allocated:Command.Command.FeatureBigCover)
}
void Command::set_allocated_featureshowclock(::Command::FeatureShowClock* featureshowclock) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Msg();
  if (featureshowclock) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(featureshowclock);
    if (message_arena != submessage_arena) {
      featureshowclock = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, featureshowclock, submessage_arena);
    }
    set_has_featureshowclock();
    _impl_.Msg_.featureshowclock_ = featureshowclock;
  }
  // @@protoc_insertion_point(field_set_allocated:Command.Command.FeatureShowClock)
}
void Command::set_allocated_featuresetmaxvolume(::Command::FeatureSetMaxVolume* featuresetmaxvolume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_Msg();
  if (featuresetmaxvolume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(featuresetmaxvolume);
    if (message_arena != submessage_arena) {
      featuresetmaxvolume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, featuresetmaxvolume, submessage_arena);
    }
    set_has_featuresetmaxvolume();
    _impl_.Msg_.featuresetmaxvolume_ = featuresetmaxvolume;
  }
  // @@protoc_insertion_point(field_set_allocated:Command.Command.FeatureSetMaxVolume)
}
Command::Command(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.Command)
}
Command::Command(const Command& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Command* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.code_){}
    , decltype(_impl_.Msg_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.code_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  clear_has_Msg();
  switch (from.Msg_case()) {
    case kWindowStatus: {
      _this->_internal_mutable_windowstatus()->::Command::WindowStatus::MergeFrom(
          from._internal_windowstatus());
      break;
    }
    case kStatus: {
      _this->_internal_mutable_status()->::Command::Status::MergeFrom(
          from._internal_status());
      break;
    }
    case kSetVolume: {
      _this->_internal_mutable_setvolume()->::Command::SetVolume::MergeFrom(
          from._internal_setvolume());
      break;
    }
    case kSeek: {
      _this->_internal_mutable_seek()->::Command::Seek::MergeFrom(
          from._internal_seek());
      break;
    }
    case kFeatureBigCover: {
      _this->_internal_mutable_featurebigcover()->::Command::FeatureBigCover::MergeFrom(
          from._internal_featurebigcover());
      break;
    }
    case kFeatureShowClock: {
      _this->_internal_mutable_featureshowclock()->::Command::FeatureShowClock::MergeFrom(
          from._internal_featureshowclock());
      break;
    }
    case kFeatureSetMaxVolume: {
      _this->_internal_mutable_featuresetmaxvolume()->::Command::FeatureSetMaxVolume::MergeFrom(
          from._internal_featuresetmaxvolume());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Command.Command)
}

inline void Command::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.code_){0}
    , decltype(_impl_.Msg_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_Msg();
}

Command::~Command() {
  // @@protoc_insertion_point(destructor:Command.Command)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Command::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_Msg()) {
    clear_Msg();
  }
}

void Command::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Command::clear_Msg() {
// @@protoc_insertion_point(one_of_clear_start:Command.Command)
  switch (Msg_case()) {
    case kWindowStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Msg_.windowstatus_;
      }
      break;
    }
    case kStatus: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Msg_.status_;
      }
      break;
    }
    case kSetVolume: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Msg_.setvolume_;
      }
      break;
    }
    case kSeek: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Msg_.seek_;
      }
      break;
    }
    case kFeatureBigCover: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Msg_.featurebigcover_;
      }
      break;
    }
    case kFeatureShowClock: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Msg_.featureshowclock_;
      }
      break;
    }
    case kFeatureSetMaxVolume: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.Msg_.featuresetmaxvolume_;
      }
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}


void Command::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.Command)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.code_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  }
  clear_Msg();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Command::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Command.Type Type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Command::Type_IsValid(val))) {
            _internal_set_type(static_cast<::Command::Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .Command.ResponseCode Code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Command::ResponseCode_IsValid(val))) {
            _internal_set_code(static_cast<::Command::ResponseCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // .Command.WindowStatus WindowStatus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_windowstatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Command.Status Status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Command.SetVolume SetVolume = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_setvolume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Command.Seek Seek = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_seek(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Command.FeatureBigCover FeatureBigCover = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_featurebigcover(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Command.FeatureShowClock FeatureShowClock = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_featureshowclock(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Command.FeatureSetMaxVolume FeatureSetMaxVolume = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_featuresetmaxvolume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Command::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.Command)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Command.Type Type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required .Command.ResponseCode Code = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_code(), target);
  }

  switch (Msg_case()) {
    case kWindowStatus: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::windowstatus(this),
          _Internal::windowstatus(this).GetCachedSize(), target, stream);
      break;
    }
    case kStatus: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::status(this),
          _Internal::status(this).GetCachedSize(), target, stream);
      break;
    }
    case kSetVolume: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::setvolume(this),
          _Internal::setvolume(this).GetCachedSize(), target, stream);
      break;
    }
    case kSeek: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::seek(this),
          _Internal::seek(this).GetCachedSize(), target, stream);
      break;
    }
    case kFeatureBigCover: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::featurebigcover(this),
          _Internal::featurebigcover(this).GetCachedSize(), target, stream);
      break;
    }
    case kFeatureShowClock: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::featureshowclock(this),
          _Internal::featureshowclock(this).GetCachedSize(), target, stream);
      break;
    }
    case kFeatureSetMaxVolume: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::featuresetmaxvolume(this),
          _Internal::featuresetmaxvolume(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.Command)
  return target;
}

size_t Command::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Command.Command)
  size_t total_size = 0;

  if (_internal_has_type()) {
    // required .Command.Type Type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (_internal_has_code()) {
    // required .Command.ResponseCode Code = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_code());
  }

  return total_size;
}
size_t Command::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.Command)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .Command.Type Type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

    // required .Command.ResponseCode Code = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (Msg_case()) {
    // .Command.WindowStatus WindowStatus = 3;
    case kWindowStatus: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Msg_.windowstatus_);
      break;
    }
    // .Command.Status Status = 4;
    case kStatus: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Msg_.status_);
      break;
    }
    // .Command.SetVolume SetVolume = 5;
    case kSetVolume: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Msg_.setvolume_);
      break;
    }
    // .Command.Seek Seek = 6;
    case kSeek: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Msg_.seek_);
      break;
    }
    // .Command.FeatureBigCover FeatureBigCover = 7;
    case kFeatureBigCover: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Msg_.featurebigcover_);
      break;
    }
    // .Command.FeatureShowClock FeatureShowClock = 8;
    case kFeatureShowClock: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Msg_.featureshowclock_);
      break;
    }
    // .Command.FeatureSetMaxVolume FeatureSetMaxVolume = 9;
    case kFeatureSetMaxVolume: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.Msg_.featuresetmaxvolume_);
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Command::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Command::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Command::GetClassData() const { return &_class_data_; }


void Command::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Command*>(&to_msg);
  auto& from = static_cast<const Command&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.Command)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.code_ = from._impl_.code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.Msg_case()) {
    case kWindowStatus: {
      _this->_internal_mutable_windowstatus()->::Command::WindowStatus::MergeFrom(
          from._internal_windowstatus());
      break;
    }
    case kStatus: {
      _this->_internal_mutable_status()->::Command::Status::MergeFrom(
          from._internal_status());
      break;
    }
    case kSetVolume: {
      _this->_internal_mutable_setvolume()->::Command::SetVolume::MergeFrom(
          from._internal_setvolume());
      break;
    }
    case kSeek: {
      _this->_internal_mutable_seek()->::Command::Seek::MergeFrom(
          from._internal_seek());
      break;
    }
    case kFeatureBigCover: {
      _this->_internal_mutable_featurebigcover()->::Command::FeatureBigCover::MergeFrom(
          from._internal_featurebigcover());
      break;
    }
    case kFeatureShowClock: {
      _this->_internal_mutable_featureshowclock()->::Command::FeatureShowClock::MergeFrom(
          from._internal_featureshowclock());
      break;
    }
    case kFeatureSetMaxVolume: {
      _this->_internal_mutable_featuresetmaxvolume()->::Command::FeatureSetMaxVolume::MergeFrom(
          from._internal_featuresetmaxvolume());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Command::CopyFrom(const Command& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Command::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (Msg_case()) {
    case kWindowStatus: {
      if (_internal_has_windowstatus()) {
        if (!_impl_.Msg_.windowstatus_->IsInitialized()) return false;
      }
      break;
    }
    case kStatus: {
      if (_internal_has_status()) {
        if (!_impl_.Msg_.status_->IsInitialized()) return false;
      }
      break;
    }
    case kSetVolume: {
      if (_internal_has_setvolume()) {
        if (!_impl_.Msg_.setvolume_->IsInitialized()) return false;
      }
      break;
    }
    case kSeek: {
      if (_internal_has_seek()) {
        if (!_impl_.Msg_.seek_->IsInitialized()) return false;
      }
      break;
    }
    case kFeatureBigCover: {
      if (_internal_has_featurebigcover()) {
        if (!_impl_.Msg_.featurebigcover_->IsInitialized()) return false;
      }
      break;
    }
    case kFeatureShowClock: {
      if (_internal_has_featureshowclock()) {
        if (!_impl_.Msg_.featureshowclock_->IsInitialized()) return false;
      }
      break;
    }
    case kFeatureSetMaxVolume: {
      if (_internal_has_featuresetmaxvolume()) {
        if (!_impl_.Msg_.featuresetmaxvolume_->IsInitialized()) return false;
      }
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  return true;
}

void Command::InternalSwap(Command* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Command, _impl_.code_)
      + sizeof(Command::_impl_.code_)
      - PROTOBUF_FIELD_OFFSET(Command, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
  swap(_impl_.Msg_, other->_impl_.Msg_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Command::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[0]);
}

// ===================================================================

class FeatureBigCover::_Internal {
 public:
  using HasBits = decltype(std::declval<FeatureBigCover>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

FeatureBigCover::FeatureBigCover(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.FeatureBigCover)
}
FeatureBigCover::FeatureBigCover(const FeatureBigCover& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeatureBigCover* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:Command.FeatureBigCover)
}

inline void FeatureBigCover::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

FeatureBigCover::~FeatureBigCover() {
  // @@protoc_insertion_point(destructor:Command.FeatureBigCover)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeatureBigCover::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FeatureBigCover::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeatureBigCover::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.FeatureBigCover)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeatureBigCover::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeatureBigCover::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.FeatureBigCover)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.FeatureBigCover)
  return target;
}

size_t FeatureBigCover::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.FeatureBigCover)
  size_t total_size = 0;

  // required bool enabled = 1;
  if (_internal_has_enabled()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeatureBigCover::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeatureBigCover::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeatureBigCover::GetClassData() const { return &_class_data_; }


void FeatureBigCover::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeatureBigCover*>(&to_msg);
  auto& from = static_cast<const FeatureBigCover&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.FeatureBigCover)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeatureBigCover::CopyFrom(const FeatureBigCover& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.FeatureBigCover)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureBigCover::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FeatureBigCover::InternalSwap(FeatureBigCover* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeatureBigCover::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[1]);
}

// ===================================================================

class FeatureShowClock::_Internal {
 public:
  using HasBits = decltype(std::declval<FeatureShowClock>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

FeatureShowClock::FeatureShowClock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.FeatureShowClock)
}
FeatureShowClock::FeatureShowClock(const FeatureShowClock& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeatureShowClock* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:Command.FeatureShowClock)
}

inline void FeatureShowClock::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

FeatureShowClock::~FeatureShowClock() {
  // @@protoc_insertion_point(destructor:Command.FeatureShowClock)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeatureShowClock::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FeatureShowClock::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeatureShowClock::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.FeatureShowClock)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeatureShowClock::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeatureShowClock::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.FeatureShowClock)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.FeatureShowClock)
  return target;
}

size_t FeatureShowClock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.FeatureShowClock)
  size_t total_size = 0;

  // required bool enabled = 1;
  if (_internal_has_enabled()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeatureShowClock::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeatureShowClock::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeatureShowClock::GetClassData() const { return &_class_data_; }


void FeatureShowClock::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeatureShowClock*>(&to_msg);
  auto& from = static_cast<const FeatureShowClock&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.FeatureShowClock)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeatureShowClock::CopyFrom(const FeatureShowClock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.FeatureShowClock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureShowClock::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FeatureShowClock::InternalSwap(FeatureShowClock* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeatureShowClock::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[2]);
}

// ===================================================================

class FeatureSetMaxVolume::_Internal {
 public:
  using HasBits = decltype(std::declval<FeatureSetMaxVolume>()._impl_._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

FeatureSetMaxVolume::FeatureSetMaxVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.FeatureSetMaxVolume)
}
FeatureSetMaxVolume::FeatureSetMaxVolume(const FeatureSetMaxVolume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeatureSetMaxVolume* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.enabled_ = from._impl_.enabled_;
  // @@protoc_insertion_point(copy_constructor:Command.FeatureSetMaxVolume)
}

inline void FeatureSetMaxVolume::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.enabled_){false}
  };
}

FeatureSetMaxVolume::~FeatureSetMaxVolume() {
  // @@protoc_insertion_point(destructor:Command.FeatureSetMaxVolume)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeatureSetMaxVolume::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FeatureSetMaxVolume::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeatureSetMaxVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.FeatureSetMaxVolume)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.enabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeatureSetMaxVolume::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FeatureSetMaxVolume::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.FeatureSetMaxVolume)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.FeatureSetMaxVolume)
  return target;
}

size_t FeatureSetMaxVolume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.FeatureSetMaxVolume)
  size_t total_size = 0;

  // required bool enabled = 1;
  if (_internal_has_enabled()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeatureSetMaxVolume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeatureSetMaxVolume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeatureSetMaxVolume::GetClassData() const { return &_class_data_; }


void FeatureSetMaxVolume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeatureSetMaxVolume*>(&to_msg);
  auto& from = static_cast<const FeatureSetMaxVolume&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.FeatureSetMaxVolume)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _this->_internal_set_enabled(from._internal_enabled());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeatureSetMaxVolume::CopyFrom(const FeatureSetMaxVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.FeatureSetMaxVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureSetMaxVolume::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FeatureSetMaxVolume::InternalSwap(FeatureSetMaxVolume* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.enabled_, other->_impl_.enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeatureSetMaxVolume::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[3]);
}

// ===================================================================

class WindowStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<WindowStatus>()._impl_._has_bits_);
  static void set_has_visible(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

WindowStatus::WindowStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.WindowStatus)
}
WindowStatus::WindowStatus(const WindowStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WindowStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.visible_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.visible_ = from._impl_.visible_;
  // @@protoc_insertion_point(copy_constructor:Command.WindowStatus)
}

inline void WindowStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.visible_){0}
  };
}

WindowStatus::~WindowStatus() {
  // @@protoc_insertion_point(destructor:Command.WindowStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WindowStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WindowStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WindowStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.WindowStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.visible_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WindowStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .Command.WindowVisible Visible = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Command::WindowVisible_IsValid(val))) {
            _internal_set_visible(static_cast<::Command::WindowVisible>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WindowStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.WindowStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .Command.WindowVisible Visible = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_visible(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.WindowStatus)
  return target;
}

size_t WindowStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.WindowStatus)
  size_t total_size = 0;

  // required .Command.WindowVisible Visible = 1;
  if (_internal_has_visible()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_visible());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WindowStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WindowStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WindowStatus::GetClassData() const { return &_class_data_; }


void WindowStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WindowStatus*>(&to_msg);
  auto& from = static_cast<const WindowStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.WindowStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_visible()) {
    _this->_internal_set_visible(from._internal_visible());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WindowStatus::CopyFrom(const WindowStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.WindowStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WindowStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void WindowStatus::InternalSwap(WindowStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.visible_, other->_impl_.visible_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WindowStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[4]);
}

// ===================================================================

class SetVolume::_Internal {
 public:
  using HasBits = decltype(std::declval<SetVolume>()._impl_._has_bits_);
  static void set_has_valuepercent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SetVolume::SetVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.SetVolume)
}
SetVolume::SetVolume(const SetVolume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetVolume* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.valuepercent_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.valuepercent_ = from._impl_.valuepercent_;
  // @@protoc_insertion_point(copy_constructor:Command.SetVolume)
}

inline void SetVolume::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.valuepercent_){0}
  };
}

SetVolume::~SetVolume() {
  // @@protoc_insertion_point(destructor:Command.SetVolume)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetVolume::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetVolume::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.SetVolume)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.valuepercent_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetVolume::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 valuePercent = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_valuepercent(&has_bits);
          _impl_.valuepercent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetVolume::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.SetVolume)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 valuePercent = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_valuepercent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.SetVolume)
  return target;
}

size_t SetVolume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.SetVolume)
  size_t total_size = 0;

  // required int32 valuePercent = 1;
  if (_internal_has_valuepercent()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_valuepercent());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetVolume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetVolume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetVolume::GetClassData() const { return &_class_data_; }


void SetVolume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetVolume*>(&to_msg);
  auto& from = static_cast<const SetVolume&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.SetVolume)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_valuepercent()) {
    _this->_internal_set_valuepercent(from._internal_valuepercent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetVolume::CopyFrom(const SetVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.SetVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetVolume::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SetVolume::InternalSwap(SetVolume* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.valuepercent_, other->_impl_.valuepercent_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetVolume::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[5]);
}

// ===================================================================

class Seek::_Internal {
 public:
  using HasBits = decltype(std::declval<Seek>()._impl_._has_bits_);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

Seek::Seek(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.Seek)
}
Seek::Seek(const Seek& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Seek* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.value_ = from._impl_.value_;
  // @@protoc_insertion_point(copy_constructor:Command.Seek)
}

inline void Seek::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){0}
  };
}

Seek::~Seek() {
  // @@protoc_insertion_point(destructor:Command.Seek)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Seek::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Seek::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Seek::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.Seek)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.value_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Seek::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_value(&has_bits);
          _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Seek::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.Seek)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.Seek)
  return target;
}

size_t Seek::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.Seek)
  size_t total_size = 0;

  // required int32 value = 1;
  if (_internal_has_value()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_value());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Seek::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Seek::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Seek::GetClassData() const { return &_class_data_; }


void Seek::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Seek*>(&to_msg);
  auto& from = static_cast<const Seek&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.Seek)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Seek::CopyFrom(const Seek& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.Seek)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Seek::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Seek::InternalSwap(Seek* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.value_, other->_impl_.value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Seek::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[6]);
}

// ===================================================================

class Track::_Internal {
 public:
  using HasBits = decltype(std::declval<Track>()._impl_._has_bits_);
  static void set_has_track(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_artist(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

Track::Track(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.Track)
}
Track::Track(const Track& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Track* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.artist_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.track_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.active_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.artist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.artist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_artist()) {
    _this->_impl_.artist_.Set(from._internal_artist(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.track_, &from._impl_.track_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.active_) -
    reinterpret_cast<char*>(&_impl_.track_)) + sizeof(_impl_.active_));
  // @@protoc_insertion_point(copy_constructor:Command.Track)
}

inline void Track::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.artist_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.track_){0}
    , decltype(_impl_.duration_){0}
    , decltype(_impl_.active_){false}
  };
  _impl_.artist_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.artist_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Track::~Track() {
  // @@protoc_insertion_point(destructor:Command.Track)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Track::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.artist_.Destroy();
  _impl_.title_.Destroy();
}

void Track::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Track::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.Track)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.artist_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.title_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.track_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.active_) -
        reinterpret_cast<char*>(&_impl_.track_)) + sizeof(_impl_.active_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Track::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 Track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_track(&has_bits);
          _impl_.track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string Artist = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_artist();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Command.Track.Artist");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required string Title = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Command.Track.Title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int32 Duration = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_duration(&has_bits);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool Active = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_active(&has_bits);
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Track::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.Track)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 Track = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_track(), target);
  }

  // required string Artist = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_artist().data(), static_cast<int>(this->_internal_artist().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Command.Track.Artist");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_artist(), target);
  }

  // required string Title = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Command.Track.Title");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_title(), target);
  }

  // required int32 Duration = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_duration(), target);
  }

  // required bool Active = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_active(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.Track)
  return target;
}

size_t Track::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Command.Track)
  size_t total_size = 0;

  if (_internal_has_artist()) {
    // required string Artist = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_artist());
  }

  if (_internal_has_title()) {
    // required string Title = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  if (_internal_has_track()) {
    // required int32 Track = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_track());
  }

  if (_internal_has_duration()) {
    // required int32 Duration = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_duration());
  }

  if (_internal_has_active()) {
    // required bool Active = 5;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t Track::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.Track)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string Artist = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_artist());

    // required string Title = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());

    // required int32 Track = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_track());

    // required int32 Duration = 4;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_duration());

    // required bool Active = 5;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Track::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Track::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Track::GetClassData() const { return &_class_data_; }


void Track::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Track*>(&to_msg);
  auto& from = static_cast<const Track&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.Track)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_artist(from._internal_artist());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.track_ = from._impl_.track_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.active_ = from._impl_.active_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Track::CopyFrom(const Track& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.Track)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Track::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Track::InternalSwap(Track* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.artist_, lhs_arena,
      &other->_impl_.artist_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Track, _impl_.active_)
      + sizeof(Track::_impl_.active_)
      - PROTOBUF_FIELD_OFFSET(Track, _impl_.track_)>(
          reinterpret_cast<char*>(&_impl_.track_),
          reinterpret_cast<char*>(&other->_impl_.track_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Track::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[7]);
}

// ===================================================================

class Playlist::_Internal {
 public:
};

Playlist::Playlist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.Playlist)
}
Playlist::Playlist(const Playlist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Playlist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.track_){from._impl_.track_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Command.Playlist)
}

inline void Playlist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.track_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Playlist::~Playlist() {
  // @@protoc_insertion_point(destructor:Command.Playlist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Playlist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.track_.~RepeatedPtrField();
}

void Playlist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Playlist::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.Playlist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.track_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Playlist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Command.Track Track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_track(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Playlist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.Playlist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Command.Track Track = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_track_size()); i < n; i++) {
    const auto& repfield = this->_internal_track(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.Playlist)
  return target;
}

size_t Playlist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.Playlist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Command.Track Track = 1;
  total_size += 1UL * this->_internal_track_size();
  for (const auto& msg : this->_impl_.track_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Playlist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Playlist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Playlist::GetClassData() const { return &_class_data_; }


void Playlist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Playlist*>(&to_msg);
  auto& from = static_cast<const Playlist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.Playlist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.track_.MergeFrom(from._impl_.track_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Playlist::CopyFrom(const Playlist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.Playlist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Playlist::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.track_))
    return false;
  return true;
}

void Playlist::InternalSwap(Playlist* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.track_.InternalSwap(&other->_impl_.track_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Playlist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[8]);
}

// ===================================================================

class Status::_Internal {
 public:
  using HasBits = decltype(std::declval<Status>()._impl_._has_bits_);
  static void set_has_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_elapsed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_playstate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hires(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_shuffle(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_repeat(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bitrate(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_samplerate(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_bitdepth(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::Command::Playlist& playlist(const Status* msg);
  static void set_has_playlist(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_volumeraw(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000008ff) ^ 0x000008ff) != 0;
  }
};

const ::Command::Playlist&
Status::_Internal::playlist(const Status* msg) {
  return *msg->_impl_.playlist_;
}
Status::Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Command.Status)
}
Status::Status(const Status& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Status* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.codec_){}
    , decltype(_impl_.playlist_){nullptr}
    , decltype(_impl_.elapsed_){}
    , decltype(_impl_.playstate_){}
    , decltype(_impl_.hires_){}
    , decltype(_impl_.shuffle_){}
    , decltype(_impl_.repeat_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.bitrate_){}
    , decltype(_impl_.samplerate_){}
    , decltype(_impl_.bitdepth_){}
    , decltype(_impl_.volumeraw_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.codec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.codec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_codec()) {
    _this->_impl_.codec_.Set(from._internal_codec(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_playlist()) {
    _this->_impl_.playlist_ = new ::Command::Playlist(*from._impl_.playlist_);
  }
  ::memcpy(&_impl_.elapsed_, &from._impl_.elapsed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.volumeraw_) -
    reinterpret_cast<char*>(&_impl_.elapsed_)) + sizeof(_impl_.volumeraw_));
  // @@protoc_insertion_point(copy_constructor:Command.Status)
}

inline void Status::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.codec_){}
    , decltype(_impl_.playlist_){nullptr}
    , decltype(_impl_.elapsed_){0}
    , decltype(_impl_.playstate_){0}
    , decltype(_impl_.hires_){false}
    , decltype(_impl_.shuffle_){false}
    , decltype(_impl_.repeat_){0}
    , decltype(_impl_.volume_){0}
    , decltype(_impl_.bitrate_){0}
    , decltype(_impl_.samplerate_){0}
    , decltype(_impl_.bitdepth_){0}
    , decltype(_impl_.volumeraw_){0}
  };
  _impl_.codec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.codec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:Command.Status)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Status::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.codec_.Destroy();
  if (this != internal_default_instance()) delete _impl_.playlist_;
}

void Status::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:Command.Status)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.codec_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.playlist_ != nullptr);
      _impl_.playlist_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.elapsed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.volume_) -
        reinterpret_cast<char*>(&_impl_.elapsed_)) + sizeof(_impl_.volume_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.bitrate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.volumeraw_) -
        reinterpret_cast<char*>(&_impl_.bitrate_)) + sizeof(_impl_.volumeraw_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Status::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string Codec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_codec();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "Command.Status.Codec");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int32 Elapsed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_elapsed(&has_bits);
          _impl_.elapsed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 PlayState = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_playstate(&has_bits);
          _impl_.playstate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool HiRes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hires(&has_bits);
          _impl_.hires_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool Shuffle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_shuffle(&has_bits);
          _impl_.shuffle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 Repeat = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_repeat(&has_bits);
          _impl_.repeat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 Volume = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 BitRate = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_bitrate(&has_bits);
          _impl_.bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float SampleRate = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_samplerate(&has_bits);
          _impl_.samplerate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 BitDepth = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_bitdepth(&has_bits);
          _impl_.bitdepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Command.Playlist Playlist = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_playlist(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 VolumeRaw = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_volumeraw(&has_bits);
          _impl_.volumeraw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Status::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Command.Status)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string Codec = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_codec().data(), static_cast<int>(this->_internal_codec().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Command.Status.Codec");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_codec(), target);
  }

  // required int32 Elapsed = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_elapsed(), target);
  }

  // required int32 PlayState = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_playstate(), target);
  }

  // required bool HiRes = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_hires(), target);
  }

  // required bool Shuffle = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_shuffle(), target);
  }

  // required int32 Repeat = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_repeat(), target);
  }

  // required int32 Volume = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_volume(), target);
  }

  // optional int32 BitRate = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_bitrate(), target);
  }

  // optional float SampleRate = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_samplerate(), target);
  }

  // optional int32 BitDepth = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_bitdepth(), target);
  }

  // required .Command.Playlist Playlist = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::playlist(this),
        _Internal::playlist(this).GetCachedSize(), target, stream);
  }

  // required int32 VolumeRaw = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_volumeraw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Command.Status)
  return target;
}

size_t Status::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Command.Status)
  size_t total_size = 0;

  if (_internal_has_codec()) {
    // required string Codec = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_codec());
  }

  if (_internal_has_playlist()) {
    // required .Command.Playlist Playlist = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.playlist_);
  }

  if (_internal_has_elapsed()) {
    // required int32 Elapsed = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_elapsed());
  }

  if (_internal_has_playstate()) {
    // required int32 PlayState = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playstate());
  }

  if (_internal_has_hires()) {
    // required bool HiRes = 4;
    total_size += 1 + 1;
  }

  if (_internal_has_shuffle()) {
    // required bool Shuffle = 5;
    total_size += 1 + 1;
  }

  if (_internal_has_repeat()) {
    // required int32 Repeat = 6;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_repeat());
  }

  if (_internal_has_volume()) {
    // required int32 Volume = 7;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_volume());
  }

  if (_internal_has_volumeraw()) {
    // required int32 VolumeRaw = 12;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_volumeraw());
  }

  return total_size;
}
size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Command.Status)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000008ff) ^ 0x000008ff) == 0) {  // All required fields are present.
    // required string Codec = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_codec());

    // required .Command.Playlist Playlist = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.playlist_);

    // required int32 Elapsed = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_elapsed());

    // required int32 PlayState = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playstate());

    // required bool HiRes = 4;
    total_size += 1 + 1;

    // required bool Shuffle = 5;
    total_size += 1 + 1;

    // required int32 Repeat = 6;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_repeat());

    // required int32 Volume = 7;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_volume());

    // required int32 VolumeRaw = 12;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_volumeraw());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000700u) {
    // optional int32 BitRate = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bitrate());
    }

    // optional float SampleRate = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional int32 BitDepth = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bitdepth());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Status::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Status::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Status::GetClassData() const { return &_class_data_; }


void Status::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Status*>(&to_msg);
  auto& from = static_cast<const Status&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Command.Status)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_codec(from._internal_codec());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_playlist()->::Command::Playlist::MergeFrom(
          from._internal_playlist());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.elapsed_ = from._impl_.elapsed_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.playstate_ = from._impl_.playstate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.hires_ = from._impl_.hires_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.shuffle_ = from._impl_.shuffle_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.repeat_ = from._impl_.repeat_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.volume_ = from._impl_.volume_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.bitrate_ = from._impl_.bitrate_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.samplerate_ = from._impl_.samplerate_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.bitdepth_ = from._impl_.bitdepth_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.volumeraw_ = from._impl_.volumeraw_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Command.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_playlist()) {
    if (!_impl_.playlist_->IsInitialized()) return false;
  }
  return true;
}

void Status::InternalSwap(Status* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.codec_, lhs_arena,
      &other->_impl_.codec_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Status, _impl_.volumeraw_)
      + sizeof(Status::_impl_.volumeraw_)
      - PROTOBUF_FIELD_OFFSET(Status, _impl_.playlist_)>(
          reinterpret_cast<char*>(&_impl_.playlist_),
          reinterpret_cast<char*>(&other->_impl_.playlist_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Status::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_command_2eproto_getter, &descriptor_table_command_2eproto_once,
      file_level_metadata_command_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Command
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Command::Command*
Arena::CreateMaybeMessage< ::Command::Command >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::Command >(arena);
}
template<> PROTOBUF_NOINLINE ::Command::FeatureBigCover*
Arena::CreateMaybeMessage< ::Command::FeatureBigCover >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::FeatureBigCover >(arena);
}
template<> PROTOBUF_NOINLINE ::Command::FeatureShowClock*
Arena::CreateMaybeMessage< ::Command::FeatureShowClock >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::FeatureShowClock >(arena);
}
template<> PROTOBUF_NOINLINE ::Command::FeatureSetMaxVolume*
Arena::CreateMaybeMessage< ::Command::FeatureSetMaxVolume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::FeatureSetMaxVolume >(arena);
}
template<> PROTOBUF_NOINLINE ::Command::WindowStatus*
Arena::CreateMaybeMessage< ::Command::WindowStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::WindowStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::Command::SetVolume*
Arena::CreateMaybeMessage< ::Command::SetVolume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::SetVolume >(arena);
}
template<> PROTOBUF_NOINLINE ::Command::Seek*
Arena::CreateMaybeMessage< ::Command::Seek >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::Seek >(arena);
}
template<> PROTOBUF_NOINLINE ::Command::Track*
Arena::CreateMaybeMessage< ::Command::Track >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::Track >(arena);
}
template<> PROTOBUF_NOINLINE ::Command::Playlist*
Arena::CreateMaybeMessage< ::Command::Playlist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::Playlist >(arena);
}
template<> PROTOBUF_NOINLINE ::Command::Status*
Arena::CreateMaybeMessage< ::Command::Status >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Command::Status >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
